parameters:
  customDotnetVersion: ''
  buildConfiguration: 'Release'
  apiName: ''
  apiDescription: ""
  productDescription: ""
  dockerContainerTag: ''
  dockerId: ''


stages:

#############################################################################################        
# Stage: Build
#############################################################################################        

- stage: Build

  jobs:

  - job: Build

    pool:
      vmImage: 'ubuntu-latest'

    variables:
      swaggerChanged: 0

    steps:
    
    - checkout: self
      submodules: true
      
    - template: 'azure-pipelines/git-version.yml@templates'

    # this step uses GitVersion to set a few variables that are available across all 
    # stages of the build (by saving them each into a separate artifact file under /variables)
    # To retrieve them, invoke retrieve-build-variables.yml@templates
    # - template: 'azure-pipelines/set-build-variables.yml@templates'

    # this step just saves the version to a file - the whole variables folder will be published
    # as an archive at the end of this stage so that it can be downloaded and used in later stages
    - bash: |
        mkdir -p $(Pipeline.Workspace)/variables
        echo "$(GitVersion.SemVer)" > $(Pipeline.Workspace)/variables/buildVersion
        cat $(Pipeline.Workspace)/variables/buildVersion
      displayName: 'Saving buildVersion variable into a file'

    - task: Assembly-Info-NetFramework@2
      displayName: 'Version API'
      inputs:
        Configuration: '${{ parameters.buildConfiguration }}'
        Path: '$(Build.SourcesDirectory)/src/${{ parameters.apiName }}'
        FileNames: '**/AssemblyInfo.cs'
        InsertAttributes: false
        FileEncoding: 'auto'
        WriteBOM: false
        Title: '${{ parameters.apiDescription }}'
        Product: '${{ parameters.productDescription }}'
        Description: 'semanticVersion=$(GitVersion.FullSemVer); branch=$(Build.SourceBranch); commit=$(GitVersion.ShortSha)'
        Company: 'Adaptive Development'
        Copyright: 'Ciprian Toader'
        VersionNumber: '$(GitVersion.AssemblySemVer)'
        FileVersionNumber: '$(GitVersion.AssemblySemFileVer)'
        InformationalVersion: '$(GitVersion.InformationalVersion)'

    - bash: |
        export NUGET_VERSION="$(GitVersion.NuGetVersionV2)-$(GitVersion.BuildMetaData)"
        if [[ $(Build.SourceBranch) == "refs/heads/master" ]]; then
          NUGET_VERSION="$(GitVersion.Major).$(GitVersion.Minor).$(GitVersion.Patch)-$(GitVersion.BuildMetaData)"
        elif [[ $(Build.SourceBranch) == "refs/heads/develop" ]]; then
          # Note: GitVersion increments develop builds automatically so we don't need to append the metadata to ensure uniqueness
          NUGET_VERSION="$(GitVersion.NuGetVersionV2)"
        fi
        echo '##vso[task.setvariable variable=nugetVersion;]'$NUGET_VERSION
      displayName: 'Calculate Nuget version'

    - bash: 'echo nugetVersion: $(nugetVersion)'
      displayName: 'Display Nuget version'
        
    - task: Assembly-Info-NetCore@2
      displayName: 'Version Proxy client'
      inputs:
        Path: '$(Build.SourcesDirectory)/src/${{ parameters.apiName }}Proxy'
        FileNames: '**/*.csproj'
        InsertAttributes: true
        FileEncoding: 'auto'
        WriteBOM: false
        GeneratePackageOnBuild: false
        Authors: 'Ciprian Toader'
        Company: 'Adaptive Development'
        Product: '${{ parameters.productDescription }}'
        Description: '${{ parameters.apiDescription }}'
        VersionNumber: '$(GitVersion.FullSemVer)'
        FileVersionNumber: '$(GitVersion.AssemblySemFileVer)'
        InformationalVersion: '$(GitVersion.InformationalVersion)'
        #PackageVersion: '$(GitVersion.FullSemVer)'
        #PackageVersion: '$(GitVersion.NuGetVersionV2)-$(GitVersion.BuildMetaDataPadded)'
        PackageVersion: '$(nugetVersion)'

    - bash: sudo apt-get install jq
      displayName: 'Installing build dependency: jq'

    - template: 'azure-pipelines/install-custom-sdk.yml@templates'
      parameters:
        sdk: '${{ parameters.customDotnetVersion }}'
        
    # create links to .NET Core Runtimes from v. 2.2 because it is needed by 'dotnet swagger' CLI
    - bash: ln -s /usr/share/dotnet/shared/Microsoft.NETCore.App/2.2.?/ $(dirname `which dotnet`)/shared/Microsoft.NETCore.App
      displayName: 'Create link to NETCoreApp 2.2 runtime (for dotnet CLI 3.0)'
    - bash: ln -s /usr/share/dotnet/shared/Microsoft.AspNetCore.App/2.2.?/ $(dirname `which dotnet`)/shared/Microsoft.AspNetCore.App
      displayName: 'Create link to AspNetCore 2.2 runtime (for dotnet CLI 3.0)'
        
    - task: DotNetCoreCLI@2
      displayName: 'Restore NuGet dependencies'
      inputs:
        command: 'restore'
        projects: './${{ parameters.apiName }}.sln'
        feedsToUse: 'config'
        nugetConfigPath: './NuGet.Config'
        
    - task: DotNetCoreCLI@2
      displayName: 'Build solution'
      inputs:
        command: 'build'
        projects: './${{ parameters.apiName }}.sln'
        arguments: '--no-restore --configuration ${{ parameters.buildConfiguration }}'

    - task: DotNetCoreCLI@2
      displayName: 'Publish API binaries'
      inputs:
        command: 'publish'
        projects: './${{ parameters.apiName }}.sln'
        zipAfterPublish: false
        publishWebProjects: true
        arguments: '--no-build --configuration ${{ parameters.buildConfiguration }}'

    - bash: 'cp $(System.DefaultWorkingDirectory)/src/${{ parameters.apiName }}Proxy/AutoGeneratedSwaggerDefinition/swagger.json $(System.DefaultWorkingDirectory)/swagger_$(GitVersion.SemVer).json'

    # archive swagger.json immediately after building to increase chances it will be saved to the build
    # even if one of the build steps fails
    - task: PublishBuildArtifacts@1
      displayName: 'Publish generated swagger.json file for this build.'
      inputs:
        pathToPublish: '$(System.DefaultWorkingDirectory)/swagger_$(GitVersion.SemVer).json'
        artifactName: 'swagger'

    - task: DownloadPipelineArtifact@2
      displayName: 'Retrieve swagger.json from previous build'
      # TODO: review this condition (for this step and all related steps)
      condition: or(eq(variables['Build.SourceBranch'], 'refs/heads/master'), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
      inputs:
        artifact: 'swagger'
        path: '$(Pipeline.Workspace)'
        source: 'specific'
        pipeline: '$(System.DefinitionId)'
        project: '$(System.TeamProjectId)'
        runVersion: 'latestFromBranch'
        runBranch: '$(Build.SourceBranch)'

    - bash: 'echo +++ swaggerChanged variable before being set: $(swaggerChanged)'

    - bash: |
        ls -la $(Pipeline.Workspace)/swagger*.json
        SWAGGER_OUTPUT=$(cmp $(System.DefaultWorkingDirectory)/src/${{ parameters.apiName }}Proxy/AutoGeneratedSwaggerDefinition/swagger.json $(Pipeline.Workspace)/swagger*.json)
        export SWAGGER_CMP_EXIT_CODE=$?
        #echo $? | setvar -name swaggerChanged -isOutput
        echo SWAGGER_CMP_EXIT_CODE=$SWAGGER_CMP_EXIT_CODE
        echo '##vso[task.setvariable variable=swaggerChanged;]'$SWAGGER_CMP_EXIT_CODE
      condition: or(eq(variables['Build.SourceBranch'], 'refs/heads/master'), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
      displayName: 'Creating Azure pipelines variable swaggerChanged'

    #        - bash: |
    #            SWAGGER_OUTPUT=$(cmp $(Pipeline.Workspace)/BuiltSourceTree/src/Api.Core.SolarMeasurementsProxy/AutoGeneratedSwaggerDefinition/swagger.json $(Pipeline.Workspace)/swagger.json)
    #            SWAGGER_CHANGED=$?
    #            echo "bash comparison stdout: $SWAGGER_OUTPUT"
    #            echo "bash comparison exit code: $SWAGGER_CHANGED"
    #            echo "##vso[task.setvariable variable=swaggerChanged]$SWAGGER_CHANGED"
    #          displayName: 'Creating Azure pipelines variable swaggerChanged'

    - bash: 'echo +++ swaggerChanged variable after being set: $(swaggerChanged)'

    - task: DotNetCoreCLI@2
      displayName: 'Create Proxy Client Nuget packages (nupkg and snupkg)'
      condition: ne(variables['swaggerChanged'], '0')
      inputs:
        command: 'custom'
        projects: '$(System.DefaultWorkingDirectory)/src/${{ parameters.apiName }}Proxy/*.csproj'
        custom: 'pack'
        arguments: '--no-build --configuration ${{ parameters.buildConfiguration }} --output $(System.DefaultWorkingDirectory)/packages'

    - publish: $(System.DefaultWorkingDirectory)/packages
      displayName: 'Archive Nuget packages'
      condition: ne(variables['swaggerChanged'], '0')
      artifact: ProxyNugetPackages

        
    - bash: ls -la $(System.DefaultWorkingDirectory)/src/${{ parameters.apiName }}/bin/${{ parameters.buildConfiguration }}/netcoreapp3.0

    - publish: $(System.DefaultWorkingDirectory)/src/${{ parameters.apiName }}/bin/${{ parameters.buildConfiguration }}/netcoreapp3.0/publish
      displayName: 'Archive API binaries'
      artifact: ApiBinaries

    - publish: $(System.DefaultWorkingDirectory)/src/${{ parameters.apiName }}/Dockerfile
      displayName: 'Archive Dockerfile'
      artifact: Dockerfile

      # Note: we cannot publish just the binaries for the unit and integration tests because we also need the source code
#       when we do code coverage
#    - publish: $(System.DefaultWorkingDirectory)/test/unit/Api.Core.SolarMeasurementsUnitTests/bin/${{ parameters.buildConfiguration }}/netcoreapp3.0/publish/
#      displayName: 'Archive Unit test binaries'
#      artifact: UnitTestBinaries
#
#    - publish: $(System.DefaultWorkingDirectory)/test/integration/Api.Core.SolarMeasurementsIntegrationTests/bin/${{ parameters.buildConfiguration }}/netcoreapp3.0/publish/
#      displayName: 'Archive Integration test binaries'
#      artifact: IntegrationTestBinaries

    - publish: $(System.DefaultWorkingDirectory)
      displayName: 'Archive fully built source tree'
      artifact: BuiltSourceTree

      # Publish all variables from this stage as a pipeline artifact
    - publish: $(Pipeline.Workspace)/variables
      displayName: 'Publishing variables for a later stage'
      artifact: variables


  #############################################################################################        
  # Stage: Tests
  #############################################################################################        

- stage: Tests

  jobs:

    - job: UnitTests

      displayName: 'Run unit tests'

      pool:
        vmImage: 'ubuntu-latest'
      
      steps:

        # skip source code checkout since we've already built and archived it 
        - checkout: none
          
        - download: current
          artifact: BuiltSourceTree
            
        - template: 'azure-pipelines/install-custom-sdk.yml@templates'
          parameters:
            sdk: '${{ parameters.customDotnetVersion }}'
            
        - task: DotNetCoreCLI@2
          displayName: 'Run unit tests'
          inputs:
            command: 'test'
            projects: '$(Pipeline.Workspace)/BuiltSourceTree/test/unit/${{ parameters.apiName }}UnitTests/${{ parameters.apiName }}UnitTests.csproj'
            testRunTitle: 'Run unit tests'
            publishTestResults: true
            arguments: '--no-build --configuration ${{ parameters.buildConfiguration }}'

        - bash: echo "Publish results..."
        - bash: echo "Save coverage report..."

    - job: IntegrationTests
      dependsOn: []    # this removes the implicit dependency on previous job and causes this to run in parallel
      displayName: 'Run integration tests'
      pool:
        vmImage: 'ubuntu-latest'
      steps:

        # skip source code checkout since we've already built and archived it 
        - checkout: none

        - download: current
          artifact: BuiltSourceTree

        - template: 'azure-pipelines/install-custom-sdk.yml@templates'
          parameters:
            sdk: '${{ parameters.customDotnetVersion }}'

        - task: DotNetCoreCLI@2
          displayName: 'Run integration tests'
          inputs:
            command: 'test'
            projects: '$(Pipeline.Workspace)/BuiltSourceTree/test/integration/${{ parameters.apiName }}IntegrationTests/${{ parameters.apiName }}IntegrationTests.csproj'
            testRunTitle: 'Run integration tests'
            publishTestResults: true
            arguments: '--no-build --configuration ${{ parameters.buildConfiguration }}'
  
        - bash: echo "Publish results..."
        - bash: echo "Save coverage report..."

  #############################################################################################        
  # Stage: Publish
  #############################################################################################        

- stage: Publish
  jobs:
    - job: DockerImageCreate

      displayName: 'Publish API Docker image for the API'

      pool:
        vmImage: 'ubuntu-latest'

      steps:
        - checkout: none

#        - download: current
#          artifact: ApiBinaries
#          
#        - download: current
#          artifact: Dockerfile
          
        - download: current
          artifact: BuiltSourceTree 
          
        - bash: ls -lF $(Pipeline.Workspace)/BuiltSourceTree 
        #ApiBinaries $(Pipeline.Workspace)/Dockerfile $(Pipeline.Workspace)/TestResults
          
        - download: current
          displayName: 'Retrieve "variables" from pipeline archive'
          artifact: variables

        # Read the variable from the file under pipeline variables artifact, then expose it in the job
        #- task: setvar@0
        #- bash: cat $(Pipeline.Workspace)/variables/buildVersion | setvar -name buildVersion -isOutput
        #  displayName: 'Retrieve buildVersion'
        - bash: |
            ls -la $(Pipeline.Workspace)/variables
            cat $(Pipeline.Workspace)/variables/buildVersion
            export BUILD_VERSION=`cat $(Pipeline.Workspace)/variables/buildVersion`
            echo buildVer is $BUILD_VERSION
            echo '##vso[task.setvariable variable=buildVersion;]'$BUILD_VERSION
          displayName: 'Retrieve buildVersion'
          
        - bash: echo Retrieved buildVersion $(buildVersion)
          displayName: 'Log buildVersion $(buildVersion)'

        - task: Docker@2
          displayName: 'Login to DockerHub'
          inputs:
            command: 'login'
            containerRegistry: 'DockerHub connection (xen22)'

        - task: Docker@2
          displayName: 'Create Docker image'
          inputs:
            command: 'build'
            Dockerfile: '$(Pipeline.Workspace)/BuiltSourceTree/src/${{ parameters.apiName }}/Dockerfile'
            tags: '$(buildVersion)'
            repository: '${{ parameters.dockerId }}/${{ parameters.dockerContainerTag }}'
            
        #- script: docker build -f $(Pipeline.Workspace)/BuiltSourceTree/src/Api.Core.SolarMeasurements/Dockerfile -t ${{ parameters.dockerId }}/api.core.solarmeasurements:$(version)-$(Build.BuildId) .  # add options to this command to meet your needs

        - task: Docker@2
          displayName: 'Push Docker image'
          inputs:
            command: 'push'
            Dockerfile: '$(Pipeline.Workspace)/BuiltSourceTree/src/${{ parameters.apiName }}/Dockerfile'
            tags: '$(buildVersion)'
            repository: '${{ parameters.dockerId }}/$(dockerContainerName)'

    - job: CreateApiProxy
      displayName: 'Create and publish API Proxy to NuGet repo'
      pool:
        vmImage: 'ubuntu-latest'

      variables:
        swaggerChanged: 0

      steps:
        - template: 'azure-pipelines/install-custom-sdk.yml@templates'
          parameters:
            sdk: '${{ parameters.customDotnetVersion }}'

        - download: current
          artifact: BuiltSourceTree

        - task: DownloadPipelineArtifact@2
          displayName: 'Retrieve swagger.json from previous build'
          inputs:
            artifact: 'swagger'
            path: '$(Pipeline.Workspace)'
            source: 'specific'
            pipeline: '$(System.DefinitionId)'
            project: '$(System.TeamProjectId)'
            runVersion: 'latestFromBranch'
            runBranch: '$(Build.SourceBranch)'

        - bash: 'echo +++ swaggerChanged variable before being set: $(swaggerChanged)'
            
        - bash: |
            ls -la $(Pipeline.Workspace)/swagger*.json
            SWAGGER_OUTPUT=$(cmp $(Pipeline.Workspace)/BuiltSourceTree/src/${{ parameters.apiName }}Proxy/AutoGeneratedSwaggerDefinition/swagger.json $(Pipeline.Workspace)/swagger*.json)
            export SWAGGER_CMP_EXIT_CODE=$?
            echo SWAGGER_CMP_EXIT_CODE=$SWAGGER_CMP_EXIT_CODE
            echo '##vso[task.setvariable variable=swaggerChanged;]'$SWAGGER_CMP_EXIT_CODE
          condition: or(eq(variables['Build.SourceBranch'], 'refs/heads/master'), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
          displayName: 'Creating Azure pipelines variable swaggerChanged'

        - bash: 'echo +++ swaggerChanged variable after being set: $(swaggerChanged)'

        - download: current 
          displayName: 'Download Nuget packages'
          condition: ne(variables['swaggerChanged'], '0')
          artifact: ProxyNugetPackages

        - task: NuGetToolInstaller@1
          displayName: 'Install NuGet v. 4.9.0 or newer (which supports symbol packages)'
          inputs:
            versionSpec: '>=4.9.0'
            
        - task: NuGetCommand@2
          displayName: 'Publish Proxy Client Nuget package'
          condition: ne(variables['swaggerChanged'], '0')
          inputs:
            command: 'push'
            packagesToPush: '$(Pipeline.Workspace)/ProxyNugetPackages/*.nupkg;!$(Pipeline.Workspace)/ProxyNugetPackages/*.snupkg'
            nuGetFeedType: 'external'
            publishFeedCredentials: 'Nuget.org service connection'
            allowPackageConflicts: true

        # Note: this appears to be pushed automatically with the nupkg above
        # - task: NuGetCommand@2
        #   displayName: 'Publish Proxy Client Nuget symbol package'
        #   condition: ne(variables['swaggerChanged'], '0')
        #   inputs:
        #     command: 'push'
        #     packagesToPush: '$(Pipeline.Workspace)/ProxyNugetPackages/*.snupkg'
        #     nuGetFeedType: 'external'
        #     publishFeedCredentials: 'Nuget.org service connection'
        #     allowPackageConflicts: true

